{
		"language": "Solidity",
		"sources": {
			"GovFactory.sol": {
				"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\n\nimport {IGovernor} from './IGovernor.sol';\nimport {PYEGov} from './Governor.sol';\n\ncontract GovFactory{\n\n    mapping(address => address) spaces;\n\n    uint256 deployed = 0;\n\n    event SpaceCreated(address, address);\n\n    function createSpace(address _tokenaddr ,bool _snap) public returns(address space){\n        require(spaces[_tokenaddr]==address(0x0),\"Space already exists for token\");\n         \n        bytes memory bytecode = type(PYEGov).creationCode;\n        \n        bytes32 salt = keccak256(abi.encodePacked(_tokenaddr));\n        \n        assembly{\n         \n            space := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        \n        }\n        \n        spaces[_tokenaddr] = space;\n        \n        IGovernor(space).init(_tokenaddr, _snap);\n        \n        emit SpaceCreated(_tokenaddr, space);\n\n        deployed++;\n    }\n\n    function numdeployed() external view returns (uint256){}\n    \n}\n\n"
			},
			"Governor.sol": {
				"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\n\n\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IGov is IERC20 {\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function snapshot() external returns (uint256);\n\n    function balanceOfAt(address account, uint256 snapshotId) external view virtual returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function totalSupplyAt(uint256 snapshotId) external view virtual returns (uint256);\n\n    function getCurrentSnapshotId() external view returns (uint256);\n\n}\n\ncontract PYEGov{\n\n    address public tokenaddress;\n\n    //address factory = 0x2Ac164e7D2B38e4f853FEC79e2bFd453E1B3201C;\n\n    struct Proposal{\n\n        uint256 createdtime;\n\n        uint256 endtime;\n\n        uint256 votesreceived;\n\n        uint256 votesfor;\n\n        uint256 votesagainst;\n\n        mapping(address => bool) voted; \n\n        string proposal;\n\n        uint256 snapId;\n\n    }\n\n    mapping(uint256 => Proposal) propID;\n\n    struct Weights{\n\n        mapping(address => uint256) delegated;\n\n        address[] delegators;\n\n        uint256 votes;\n    } \n\n    mapping(address => Weights) weight;\n\n    bool snap;\n\n    bool inited;\n\n    uint256 currprop = 0;\n\n    event initialize(address token);\n\n    event newproposal(uint256, string);\n\n    event Vote(bool, uint256);\n\n    function getWeight(uint256 _prop) internal returns (uint256){\n\n        if(snap){\n        \n            weight[msg.sender].votes = IGov(tokenaddress).balanceOfAt(msg.sender, propID[_prop].snapId);\n        \n        }\n        else{\n        \n            weight[msg.sender].votes = IGov(tokenaddress).balanceOf(msg.sender);\n        \n        }\n\n        return weight[msg.sender].votes;\n    }\n\n    function getSupply(uint256 id) internal returns (uint256){\n        uint256 sup;\n        if(snap){\n        \n            sup = IGov(tokenaddress).totalSupplyAt(id);\n        \n        }\n        else{\n        \n            sup = IGov(tokenaddress).totalSupply();\n        \n        }\n\n        return sup;\n    }\n\n    function vote(bool myvote, uint256 prop) public {\n        require( propID[prop].endtime > block.timestamp, \"Voting ended\" );\n        \n        require( propID[prop].voted[msg.sender]!= true, \"Already voted\");\n\n        getWeight(prop);\n\n        if(myvote){\n        \n            propID[prop].votesfor = weight[msg.sender].votes;\n        \n            propID[prop].votesreceived = weight[msg.sender].votes;\n        \n        }\n        \n        else{\n        \n            propID[prop].votesagainst = weight[msg.sender].votes;\n\n            propID[prop].votesreceived = weight[msg.sender].votes;\n        \n        }\n        \n        propID[prop].voted[msg.sender] = true;\n        \n        emit Vote(myvote, prop);\n    }\n\n    function initprop(string memory propmsg, uint256 _endtime) public {\n        if(currprop == 0){propID[currprop].snapId = IGov(tokenaddress).getCurrentSnapshotId();}\n        \n        uint256 wt = getWeight(currprop);\n\n        uint256 ts = getSupply(propID[currprop].snapId);\n\n        require(wt > (ts/100) , \"Need 1% to submit prop\");\n\n        currprop++;\n\n        propID[currprop].proposal = propmsg;\n\n        propID[currprop].votesfor += weight[msg.sender].votes;\n\n        propID[currprop].voted[msg.sender] = true;\n\n        propID[currprop].snapId = IGov(tokenaddress).snapshot();\n\n        propID[currprop].createdtime = block.timestamp;\n\n        propID[currprop].endtime = block.timestamp + _endtime;\n        \n        if(weight[msg.sender].delegators.length > 0){\n            removemydelegators();\n        }\n\n        emit newproposal(currprop , propmsg);\n  \n    }\n\n    function init(address tokenaddr, bool selsnap)external{\n        require( !inited , \"only factory can initialize\");\n        \n        currprop = 0;\n        \n        selsnap = snap;\n        \n        tokenaddress = tokenaddr;\n        \n        inited = true;\n        \n        emit initialize(tokenaddress);\n    }\n\n    function combineWeight(address del)public{\n        weight[del].votes += weight[msg.sender].votes;\n\n        weight[del].delegated[msg.sender] += weight[msg.sender].votes;\n\n        weight[del].delegators[weight[msg.sender].delegators.length] = msg.sender;\n\n        weight[msg.sender].votes = 0;\n    }\n    \n    function removemydelegators() internal {\n        uint i = 0;\n        for(i = 0; i < weight[msg.sender].delegators.length ; i++){\n\n            address del;\n\n            del = weight[msg.sender].delegators[i];\n\n            weight[msg.sender].votes -= weight[msg.sender].delegated[del];\n\n            weight[del].votes = weight[msg.sender].delegated[del];\n            \n            propID[currprop].voted[del] = true;\n            \n            weight[msg.sender].delegators[i] = address(0x0);\n            \n        }\n    }\n\n\n}"
			},
			"IGovernor.sol": {
				"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\n\ninterface IGovernor {\n\n    event initialize(address token);\n\n    event newproposal(uint256, string);\n\n    event Vote(bool, uint256);\n\n    function vote(bool vote, uint256 prop) external;\n\n    function initprop(string memory , uint256) external;\n\n    function init(address tokenaddr, bool selsnap) external;\n\n    function combineWeight(address del) external;\n\n}"
			},
			"@openzeppelin/contracts/token/ERC20/IERC20.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
			}
		},
		"settings": {
			"optimizer": {
				"enabled": false,
				"runs": 200
			}
		}
	}